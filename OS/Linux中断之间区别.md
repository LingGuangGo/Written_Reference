## Linux中断区别

### 硬件中断和软件中断

| 中断区别    | 硬件中断                  | 软件中断                                             |
| ----------- | ------------------------- | ---------------------------------------------------- |
| 中断源产生  | 硬件外设                  | 执行中断指令                                         |
| 中断号提供  | 中断控制器                | 由指令直接指出                                       |
| 可屏蔽      | 可屏蔽                    | 不可屏蔽                                             |
| ISR中断分层 | 上半部分ISR: 需要快速完成 | 下半部ISR, 通过软中断完成                            |
|             |                           | 软中断: 处理硬中断未完成的工作, 是一种推后执行的机制 |

1. 硬件中断
   + 硬件外设: 由与系统相连的外设(比如网卡 硬盘 键盘等)自动产生
   + 每个设备或设备集都有他自己的IRQ(中断请求), 基于IRQ
     + CPU可以将相应的**请求**分发到相应的**硬件驱动**上
     + 硬件驱动通常是内核中的一个子程序, 而不是一个独立的进程
   + **处理中断的驱动**: 是需要运行在CPU上的, 当中断产生时, CPU会暂时停止当前程序的程序转而执行中断请求;
2. 软件中断
   + 不会直接中断CPU, 当前正在运行的代码(或进程)才会产生软中断;
   + 软中断: 是一种需要内核为正在运行的进程去做一些事情(通常为I/O)的请求;

### 软中断和硬中断

| 区别     | 软中断                                     | 硬中断                  | 信号                                       |
| -------- | ------------------------------------------ | ----------------------- | ------------------------------------------ |
| 中断类型 | **硬中断服务程序**(下半部)对**内核**中断   | 外部设备对**CPU**的中断 | 是由**内核**（或进程）对某个**进程**的中断 |
| 抢占     | 软中断之间不抢占，保证严格的时间要求       | 发生抢占                |                                            |
|          | 软中断的服务程序：执行上下文为软中断daemon |                         |                                            |

1. 软中断(ISR下半部分的中断)
   + 概念: 用软件方式模拟硬件中断的概念，实现宏观上的异步执行效果, 类似于信号;
   + 软中断的一种典型应用就是所谓的"**下半部**"（bottom half）: 它的得名来自于将硬件中断处理分离成"上半部"和"下半部"两个阶段的机制：
2. 软中断和函数调用区别？
   + 函数调用时将返回地址和CPU状态寄存器内容压栈，函数执行完毕后出栈返回断点继续执行。
   + 软中断调用时将返回地址和CPU状态寄存器内容压栈，**修改特权级**，根据**中断号查找中断向量表**，找到ISR中断服务例程地址，跳转执行。
   + 函数调用和软中断调用的区别是: 软中断多了修改特权级和查找中断向量表的功能，其他部分完全一样。

### Linux软中断实现的原理

1. 构成软中断机制的核心元素包括：

   + 软中断状态寄存器soft interrupt state（irq_stat）

   + 软中断向量表（softirq_vec）: 不同的中断号有不同的终端入口地址；

   + 软中断守护daemon

2. **软中断如何模拟：硬件中断？**

   + 当某一软中断事件发生：首先需要**设置**对应的**中断标记位**，触发中断事务（raise_softirq()：设置软中断状态bitmap，触发软中断事务）

   + 然后唤醒**守护线程**：去检测中断状态寄存器；

     ```
     do_softirq();	//在Linux中 软中断daemon线程函数
     ```

   + 如果查询：发现某一软中断事务发生之后，那么通过软**中断向量表**调用软中断服务程序action()

3. 软中断模拟硬件中断的区别在哪里？

   + 区别：从**中断标记**  ---->   中断服务程序  的映射过程
   + 硬件中断：CPU从硬件中断发生后，将中断请求通过向量表映射成具体的服务程序，过程是硬件自动完成，硬件主动提供ISR入口地址；
   + 软中断：需要**守护线程**去实现这一过程