## [linux内存管理原理的介绍](https://www.cnblogs.com/dongzhiquan/p/5621906.html)

### linux的ioremap

1. 因为内核没有办法直接访问物理内存地址，必须先通过ioremap获得对应的虚拟地址

### **Linux** **的虚拟内存管理有几个关键概念：**

1. 每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址； 
2. 虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址； 
3. 如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。

### Linux 虚拟地址空间如何分布？

1. Linux 使用虚拟地址空间，大大增加了进程的寻址空间，**由低地址到高地址分别为**： 

+ 代码段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) ) 

+ 数据段：保存全局变量、静态变量的空间； 

+ **堆 ：**就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 

+ 文件映射区域：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间

+ 栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 

+ 内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)。 

  ![linux_memory.png](https://github.com/quronghui/Embedded-written-reference/blob/master/OS/photo/asset_img.png)

2. 32bit的地址空间划分

   + 0x08048000~0xbfffffff 是用户空间
   + 0xc0000000~0xffffffff 是内核空间，包括内核代码和数据、与进程相关的数据结构（如页表、内核栈）
   + **%esp 执行栈顶，往低地址方向变化；**
   + **brk/sbrk 函数控制堆顶_edata往高地址方向变化**

3. **64bit系统的划分**

   + **地址空间大小不是2^32，也不是2^64，而一般是2^48
   + 因为并不需要 2^64 这么大的寻址空间，过大空间只会导致资源的浪费

   ```
   cat /proc/cpuinfo		// 64位Linux一般使用48位来表示虚拟地址空间，40位表示物理地址，
   ```

## malloc和free是如何分配和释放内存？

### 查看进程发生缺页中断的次数

```
$ ps -o majflt,minflt -C program		//majflt -- major fault 大错误；minflt -- minor fault
```

+ *两个数值表示一个进程自启动以来所发生的缺页中断的次数。

1. 发成缺页中断后，执行了那些操作？
   + 当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作
   + 检查要访问的虚拟地址是否合法
   + 查找/分配一个物理页
   + 充物理页内容（读取磁盘，或者直接置0，或者啥也不干）
   + 建立映射关系（虚拟地址到物理地址）
2. 系统缺页时，操作系统做了什么？
   + 在第一次访问**已分配**的虚拟地址空间的时候，发生缺页中断
   + 操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

### 进程分配内存的系统调用：brk 和mmap

+ 这两种方式分配的都是虚拟内存，没有分配物理内存
+ 第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)

1. brk是将数据段(.data)的最高地址指针_edata往高地址推；

   + _edata: **指向数据段的最高地址**

2. mmap是在进程的虚拟地址空间中（堆和栈中间，称为**文件映射区域**的地方）找一块空闲的虚拟内存

3. **内存分配的几种情况**

   | 内存分配大小         | 方法         | 具体过程                                                     |
   | -------------------- | ------------ | ------------------------------------------------------------ |
   | malloc(size < 128k ) | brk          | _edata+size；(没有分配物理地址)                              |
   | malloc(size > 128k ) | mmap         | 从堆和栈的文件映射区分配一块虚拟内存                         |
   | **方法**             | **内存释放** | **注意**                                                     |
   | brk                  | free(ptr)    | 只有高地址释放，才能释放低地址；否则会出现**内存碎片**<br />当释放的两块内存和大于128k时，执行**内存紧缩操作**（返回内存） |
   | mmap                 | munmap       | 可以随时释放内存空间                                         |

   ![memory_malloc.png](https://github.com/quronghui/Embedded-written-reference/blob/master/OS/photo/memory_malloc.png)

4. 如何查看堆内内存的碎片情况 ？

   ```
   glibc 提供的结构体:
   struct mallinfo { 
   }
   ```

5. 如果想知道堆内究竟有多少碎片:

   + 可通过 mallinfo 结构中的 fsmblks 、smblks 、ordblks 值得到，这些值表示不同大小区间的碎片总个数，这些区间分别是 0~80 字节，80~512 字节，512~128k**。

### 为何不用mmap替代brk，申请内存？ 

1. 两个问题：
   + 既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢？
   + 而是仅仅对于大于 128k 的大块内存才使用 mmap ？
2. 为什么申请空间小于128k的使用brk?
   + 进程向 OS 申请和释放地址空间的接口： sbrk/mmap/munmap 都是系统调用，频繁调用系统调用都比较消耗系统资源的。
   +  mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断
   + 缺页中断是内核行为，会导致内核态CPU消耗较大。如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。
3. 为什么申请空间大于128k时使用mmap?
   + 堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗
4. mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值