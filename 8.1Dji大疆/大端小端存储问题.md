### 大端小端存储问题

1. 大端和小端定义

   - 大端模式（BE big-endian），是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中（**低地址 对 高位，高地址 对 低位**）；
   - 小端模式（LE little-endian），是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中（**低地址对低位，高地址对高位**）。

2. 为什么会存在大端和小端区分?

   + **地址单元:** 按照Byte进行划分, 也就是8bit;
   + 如果一个值含有多个字节, 如何对其进行安排就是一个问题?

   ```
   value : 0x1122;			//	 0x11 -- 高位;	0x22	--	低位;
   adress: 16bit -- 0x0010;	
   (1)	big-endian:		0x0010 -- 0x11; 	0x0011	--	0x22;
   (2)	little-endian:	0x0010	--	0x22;	0x0011	--	0x11;
   ```

3. 题目: 四个整数在内存中的存储情况，请选择其中最大的一个。

   ![big-small-endian.png](/8.1Dji大疆/photo/big-small-endian.png)

   ```
   A：12345678、B：56781234、C：12785634、D：56341278。
   // 每个字节内部的顺序不变;
   ```


### [如何判断处理器是大端存储还是小端存储](https://blog.csdn.net/bitboss/article/details/51247869)

1. 通过指针区分大小端;

   ```
   void Judge_duan()
   {
   	int a = 1;  //定义为1是为了方便 如果你喜欢你可以随意，
   	            //只要你能搞清楚 例如：0x11223344;
    
   	char *p = (char *)&a;//在这里将整形a的地址转化为char*；
   	                     //方便后面取一个字节内容
    
   	if(*p == 1)//在这里解引用了p的一个字节的内容与1进行比较；
   		printf("小端\n");
   	else
   		printf("大端\n");
   }
   ```

   ![pointer_judge.png](/8.1Dji大疆/photo/pointer_judge.png)

2. 通过联合体进行判断

   + **联合体的概念**:   联合体的各个成员**共用内存**，并应该同时只能有一个成员得到这块**内存的使用权**（即对内存的读写），而结构体各个成员各自拥有内存，各自使用互不干涉。

   ```
   static union { 
       char c[4]; 
       unsigned long mylong; 
   } endian_test = {{ 'l', '?', '?', 'b' } };
   #define ENDIANNESS ((char)endian_test.mylong)
   ```

   + 如果是“l”（小端）、“b”（大端）

3. 常见的大端和小端判断

   

   | 类型 | 处理器        |
   | ---- | ------------- |
   | 大端 | C51           |
   | 小端 | ARM, DSP, x86 |

   

### 大端和小端转化

1. 小端转化为大端?

   + 将小端低地址存储的低位, 放在高地址上
   + 按照8bit进行移位

   ```
   int		Lendmian_convertB(int	t)
   {
   	int	result = 0;
   	int	i;
   	for( i =0; i<sizeof(t); i++){
   		result <<=	8;		// 左移8bit;
   		result	|=	(t&0xFF);	//按位或
   		t	>>=	8;
   	}
   	return result;
   }
   ```

   